#include <stdlib.h>

#include "llvm/Pass.h"
#include "llvm/IR/BasicBlock.h"
#include "llvm/IR/Instructions.h"
#include "llvm/IR/Constants.h"
#include "llvm/IR/Function.h"
#include "llvm/IR/Instruction.h"
#include "llvm/IR/LegacyPassManager.h"
#include "llvm/IR/Module.h"
#include "llvm/IR/User.h"
#include "llvm/Support/raw_ostream.h"
#include "llvm/Transforms/IPO/PassManagerBuilder.h"

using namespace llvm;

// Basic structure was taken from: https://github.com/sampsyo/llvm-pass-skeleton
// Extra information about how to make a module pass run taken from: http://stackoverflow.com/questions/36308903/llvm-pass-error-when-iterating-over-module-functions-list
// http://homes.cs.washington.edu/~bholt/posts/llvm-quick-tricks.html
namespace 
{
    struct OptimiPass : public ModulePass 
	{
        static char ID;
        OptimiPass() : ModulePass(ID) {}

        virtual bool runOnModule(Module &M) 
		{
			// get all of the global annotations then
			//     loop over them and print them to errs()
            GlobalVariable *global_annos = M.getNamedGlobal("llvm.global.annotations");
            if (global_annos) 
			{ 
              ConstantArray *a = cast<ConstantArray>(global_annos->getOperand(0));
              for (int i=0; i<a->getNumOperands(); i++) 
			  {
                ConstantStruct *e = cast<ConstantStruct>(a->getOperand(i));
                StringRef anno = cast<ConstantDataArray>(cast<GlobalVariable>(e->getOperand(1)->getOperand(0))->getOperand(0))->getAsCString();
                errs() << anno;
              }
            }

			// loop over all functions and apply any changes which are needed
            for (Module::iterator curFunc = M.begin(), endFunc = M.end(); 
					curFunc != endFunc; 
					++curFunc) 
			{
				// if the function was generated by llvm then ignore it
				if (curFunc->getName().find("llvm") != std::string::npos) 
				{ 
					continue; 
				}
				// print the name of the function
				errs() << "found function: " << curFunc->getName() << "\n";
				// loop over all of the basic blocks in the function
				for (Function::iterator curBasBloc = curFunc->begin(), endBasBloc = curFunc->end(); 
						curBasBloc != endBasBloc; 
						++curBasBloc) 
				{
					// print out the name of the block and how many instructions it has
					errs() << "\t Basic block (name=" << curBasBloc->getName() << ") has "
						<< curBasBloc->size() << " instructions \n";
					// loop over all of the instructions in the basic block
					for (BasicBlock::iterator curInstruct = curBasBloc->begin(), endInstruct = curBasBloc->end(); 
							curInstruct != endInstruct; 
							++curInstruct) 
					{
						// if the instruction is a function call
						if (isa<CallInst>(*curInstruct)) 
						{
							StringRef name = cast<CallInst>(*curInstruct).getCalledFunction()->getName();
							if (name == "llvm.var.annotation") // if this is an annotation, then get the annotation string
							{
								Value *val = cast<CallInst>(*curInstruct).getArgOperand(1); // cast to a function call and get the second operand
								Value *us = cast<User>(*val).getOperand(0); // Get the pointer to the global where the annotation is stored
								StringRef anno = cast<ConstantDataArray>(cast<User>(*us).getOperand(0))->getAsCString(); // get the annotation as a string
								errs() << "\t\t"  << anno << "\n";
							}
						}
					}
				}
            }
            return false;
        }
    };
}

char OptimiPass::ID = 0;
static RegisterPass<OptimiPass> X("passname", "Pass Name Analysis");
static void registerPass(const PassManagerBuilder &, legacy::PassManagerBase &PM) {
	PM.add(new OptimiPass());
}
static RegisterStandardPasses RegisterMyPass(PassManagerBuilder::EP_EarlyAsPossible, registerPass);
